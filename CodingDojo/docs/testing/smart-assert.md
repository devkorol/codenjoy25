В методологии Unit тестирования принят подход атомарности тестирования, когда 
1 тест тестирует 1 аспект системы и желательно содержит 1 assert, поломка которого
естественно приводит к остановке выполнения этого теста. 

Эту рекомендацию мы оставили для идеального мира и отходим от нее в наших тестах. 
В реальном мире, в котором тесты выполняются не всегда молниеносно, 
представляют собой не только unit, но и integration/system (что требует для настройки
системы до самого момента тестирования много действий и времени), 
часто требуется более 1 assert на 1 test. 

На проекте мы используем несколько подходов для ускорения взаимодействия с тестами.

Во-первых, мы проверяем assert'ом не конкретные поля тестируемого 
объекта один за другим, а его toString представление, проверяя сразу
все содержимое объекта. Этот подход частично позаимствован из
`approvals` подхода одноименной библиотеки для тестирования. 

Например, так тесты мы писали раньше:

```java
    @Test
    public void shouldTeleport_whenTurnLeft() {
        Walls walls = new Walls();
        Knibert board = new Knibert(generator, walls, BOARD_SIZE, printerFactory);
        hero = board.getHero();
        stone = board.getStone();

        hero.left();
        assertEquals("позиция X змейки", 4, hero.getX());
        assertEquals("позиция Y змейки", 4, hero.getY());
    
        for (int count = 0; count < BOARD_SIZE; count++) {
            board.tick();
        }
    
        assertEquals("позиция X змейки", 4, hero.getX());
        assertEquals("позиция Y змейки", 4, hero.getY());
        assertHeroDirection(Direction.LEFT);
    }
```

Если он поломается на любом из assert'ов ты увидишь только
```
позиция X змейки
Expected: 4
But was:  5 
```

И это тебе не скажет почти ничего о том, что не так со змейкой на поле.

Теперь мы пишем свои тесты так:

```java
    @Test
    public void shouldTeleport_whenTurnLeft() {
        // given
        givenBoardWithoutWalls();
    
        hero.left();
        board.tick();
        board.tick();
        board.tick();
        board.tick();
    
        // then
        asrtBrd("         \n" +
                "         \n" +
                "         \n" +
                "         \n" +
                "◄╕       \n" +
                "         \n" +
                "         \n" +
                "         \n" +
                "         \n");
    
        // when
        board.tick();
    
        // then
        asrtBrd("         \n" +
                "         \n" +
                "         \n" +
                "         \n" +
                "╕       ◄\n" +
                "         \n" +
                "         \n" +
                "         \n" +
                "         \n");
    
        assertEquals(true, hero.isAlive());
        assertEquals(LEFT, hero.getDirection());
    
        // when
        board.tick();
    
        // then
        asrtBrd("         \n" +
                "         \n" +
                "         \n" +
                "         \n" +
                "       ◄╕\n" +
                "         \n" +
                "         \n" +
                "         \n" +
                "         \n");
    
        assertEquals(true, hero.isAlive());
        assertEquals(LEFT, hero.getDirection());
    }
```

Во-вторых (еще один подход) подобные тесты выглядят как документация. 
Мы прикладываем для этого немалые усилия, поддерживая тестовый фреймворк в 
надлежащем уровне. Каждый раз, выделяя (extract method) низкоуровневую 
функциональность из самого теста, увеличивая читбельность и устраняя 
дублирование. Мы знаем, что тесты системы - это отдельный проект 
тестирующий production часть, со своей собственной доменной моделью, сервисами, 
утилитами и конечно же OOP/Рефакторингами и даже тестами. Да-да, весьма редко, 
но все же иногда появляются тесты на тесты - чаще конечно тесты тестируются в связке 
с production кодом, путем его поломки в месте, которое тестируется. Это одно из
рекомендаций TDD подхода, о котором читай в другой статье.    

В-третьих, каждый assert в случае поломки максимально информативен - 
ты будешь видеть всю ситуацию на поле, а не какой-то махонький аспект. 
А твоя любимая ide поможет тебе и удобно покажет diff двух строковых представлений: 
expected и actual.

В-четвертых, выполнения теста не остановится на поломанном assert по той причине, 
что мы пользуемся не Assert.assertEquals из набора jUnit, а оберткой над ним -
 SmartAssert.assertEquals. Последний накапливает все ошибки и слетает тогда, 
когда мы попросим - делаем мы это в @After блоке теста. 

```java
    @After
    public void after() {
        SmartAssert.checkResult();
    }
```

Если поломанных assert более чем 1, ты увидишь несколько блоков 
`Expected: smth But was:  smthOther` подряд. По каждому из них можно будет посмотреть 
diff с помощью твоей любимой ide. Это очень ускоряет, когда активно работаешь с тестами.

Мы так же используем нотацию `shouldЧтоБудет_whenОпределенныеДействия`. 
Возможны модификации `shouldЧтоБудет_whenОпределенныеДействия_caseУсловие1_ofЧегоТоТамЕще`. 

А внутри теста мы выделяем несколько блоков, отмечая их комментариями 
`// given`, `// when` и `// then`.  

Ты можешь обратить внимание, что часто тесты у нас так же часто являются функциональными, 
то есть тестируют несколько `// when // then` частей идущих подряд - они тестируют не 
конкретное состояние, а историю. Это делает тесты более хрупкими и неудобными 
в обращении, если только не использовать все вышеперечисленные подходы. 

Еще один подход в тестировании мы называем `paranoic mode` который гласит, 
пиши тесты не для того, чтобы подтвердить, что ты все сделал правильно, а для того,
чтобы найти еще одну ошибку из многих, которые ты оставил в коде. Мы верим, 
что программисты пишут баги. Если программист более опытный это не значит, что багов 
у него меньше чем у менее опытного коллеги - частота генерации багов у них приблизительно
одинаковая. Более опытный коллега просто пишет более злые баги. Их сложнее отловить. 
А раз так - мы часто пишем избыточные тесты, сетку тестов разных типов 
unit/integration/system/smoke/acceptance, каждый из которых лишь предлог взглянуть на код
с другой точки зрения с одной целью - найти багу. После эи все тесты остаются 
и помогают в регрессии - мы активно рефакторим свой код, и меньше беспокоимся 
за возможные его поломки в ходе реорганизации.  