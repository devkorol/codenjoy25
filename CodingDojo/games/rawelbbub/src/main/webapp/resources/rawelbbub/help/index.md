<meta charset="UTF-8">

## Вступление

Игровой demo-сервер доступен так же в интернете 24/7 в целях
ознакомления [http://codenjoy.com/codenjoy-contest](http://codenjoy.com/codenjoy-contest).

Игра с открытым исходным кодом. Для реализации своей игры, исправления
ошибок в текущей и внесения других правок необходимо для начала
[форкнуть проект](https://github.com/codenjoyme/codenjoy.git).
В корне репозитория есть описание в файле Readme.md - там описано, что делать дальше.

По возникающим вопросам, пиши в [skype alexander.baglay](skype:alexander.baglay)
или на почту [apofig@gmail.com](mailto:apofig@gmail.com).

## В чем суть игры?

Надо написать своего бота для героя, который обыграет других ботов
по очкам. Вся игра при этом проходит на одном поле. Герой может
передвигаться по свободным ячейкам во все четыре стороны.
Так же герой может выстрелить торпедой, которая взорвется при
попадании в препятствие. Торпеда движется быстрее героя в два раза.

За убийство врагов боту игрока начисляются очки[(?)](#ask). 
За смерть геройа начисляются штрафные очки[(?)](#ask). 

Мертвый герой тут же появляется в random месте на поле.

Помимо обычных вражеских субмарин есть субмарины с призами. Чтобы уничтожить
такого героя надо попасть несколько[(?)](#ask) раз. После убийства 
призовую субмарину из него выпадает приз, который нужно подобрать. Если 
этого не сделать, то через некоторое время[(?)](#ask) он исчезнет. 
За убийство призовой субмарины игроку также начисляются очки[(?)](#ask). 
Стоит быть внимательным, приз случайно можно уничтожить торпедой - 
если это случится, он так же исчезнет с поля.

Есть несколько видов призов. Каждый из которых на время дает герою
определенное преимущество:

* Подобранный во время игры приз `PRIZE_IMMORTALITY` делает героя 
  неуязвимым к вражеским торпедам. 
* А приз `PRIZE_WALKING_ON_FISHNET` даст возможность ходить через рыболовецкие сети. 
* Приз `PRIZE_BREAKING_BAD` позволит пробивать айсберги и непроходимые рифы. 
* Приз `PRIZE_VISIBILITY` дает возможность прятать технику в водорослях. 
* Приз `PRIZE_NO_SLIDING` дает возможность предотвратить занос во время прохождения
  разлива нефти. Если действие приза окончено, а герой находится 
  среди нефти, то всё будет так как будто герой только что туда заплыл.

Приз действует некоторое время. Каждый четный тик игры приз 'мерцает' символом `PRIZE`.

Очки суммируются. Побеждает игрок с большим числом очков (до условленного 
времени).

[(?)](#ask)Точное количество очков за любое действие, а так же другие 
настройки на данный момент игры уточни у Сенсея.

## Подключение к серверу

Итак, игрок [регистрируется на сервере](../../../register?gameName=rawelbbub),
указывая свой email.

Далее необходимо подключиться из кода к серверу через websocket.
[Эта подборка](https://github.com/codenjoyme/codenjoy-clients.git)
клиентов для разных языков программирования тебе поможет в твоей игре.
Как запустить клиент смотри в корне проекта в файле README.md.

Если ты не можешь найти свой язык - придется написать свой клиент
(а после пошарить с нами на почту [apofig@gmail.com](mailto:apofig@gmail.com))

Адрес для подключения к игре на сервере выглядит так (ты можешь скопировать его
из игровой комнаты):

`https://[server]/codenjoy-contest/board/player/[user]?code=[code]`

Тут `[server]` - домен или ip-адрес игрового сервера, `[user]` - id игрока, a `[code]` -
твой security token. Убедись что код хранится в тайне, иначе любой участник
сможет играть от твоего имени.

В коде твоего клиента тебе нужно найти похожую строчку и заменить её твоим URL -
тем самым, ты задаёшь логин/пароль для доступа к серверу.
Затем запусти твой клиент и убедись, что сервер получает команды твоего клиента.
После этого можно приступать к работе над логикой бота.

## Формат сообщений

После подключения клиент будет регулярно (каждую секунду) получать строку
символов с закодированным состоянием поля. Формат таков:

`^board=(.*)$`

C помощью этого regexp можно выкусить строку доски.

## Пример поля

Вот пример строки от сервера:

<pre>board=☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼             ☼☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼☼ ╬ ╬ ╬ ╬ ╬˅╬ ☼☼ ╬ ╬˂╬ ╬ ╬ ╬ ☼☼ ╬ ╬ ╬ ╬ ╬•╬ ☼☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼☼ ╬ ╬ ╠ ╬ ╬ ╬ ☼☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼☼ ╬▲╬ ╬ ╬ ╬ ╬ ☼☼             ☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼</pre>

Длинна строки равна площади поля `N*N`. Если вставить символ
переноса строки каждые `N=sqrt(length(string))` символов, то
получится читабельное изображение поля:


<pre>☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼
☼             ☼
☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼
☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼
☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼
☼ ╬ ╬ ╬ ╬ ╬˅╬ ☼
☼ ╬ ╬˂╬ ╬ ╬ ╬ ☼
☼ ╬ ╬ ╬ ╬ ╬•╬ ☼
☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼
☼ ╬ ╬ ╠ ╬ ╬ ╬ ☼
☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼
☼ ╬ ╬ ╬ ╬ ╬ ╬ ☼
☼ ╬▲╬ ╬ ╬ ╬ ╬ ☼
☼             ☼
☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼</pre>


Первый символ строки соответствует ячейке расположенной в
левом верхнем углу и имеет координату `[0, 29]`.
Координата `[0, 0]` соответствует левому нижнему углу.
В этом примере — позиция героя (символ `▲`) — `[3, 2]`, 
а торпеды (символ `•`) - `[11, 7]`.

## Расшифровка символов

Расшифровку символов ты можешь [найти тут](elements.md).

## Как играть?

Игра пошаговая, каждую секунду сервер посылает твоему клиенту
состояние обновленного поля на текущий момент и ожидает ответа
команды герою. За следующую секунду игрок должен успеть дать
команду герою. Если не успел — герой стоит на месте.

Твоя цель заставить героя двигаться в соответствии с задуманным тобой алгоритмом.
Герой на поле должен уметь зарабатывать так много очков, как только сможет.
Основная цель игры - обыграть по очкам всех соперников.

## Команды управления

Команд несколько и они зависят от выбранного Сенсеем на время 
игры формата отображения/управления[(?)](#ask):

* В классическом режиме игры вид на поле сверху команда движения выполняет 
  именно то, что в ней указано:  

  + `UP`, `DOWN`, `LEFT`, `RIGHT` – приводят к одновременному развороту и
    передвижению героя в заданном направлении на 1 клетку.
  + `ACT` - выстрел торпеды. 
  + Команды движения можно комбинировать с командами выстрела, 
    разделяя их через запятую – это значит что за один тик игры 
    будет выстрел, а потом движение `LEFT,ACT` или наоборот `ACT,LEFT`.
  
* В режиме игры "TURN/FORWARD" вид на поле так же сверху, но управление героем
  несколько отличается и делится на команды поворота и команды движения: 

  + `UP` – "полный вперед" приводит к перемещению героя на одну клетку 
    вперед по направлению движения.
  + `DOWN` – "задний ход" приводит к перемещению героя на одну клетку 
    в противоположную сторону от направления движения.
  + `LEFT` – "поворот налево" приводит к развороту героя по часовой 
    стрелке на 90 градусов.
  + `RIGHT` – "поворот направо" приводит к развороту героя против 
    часовой стрелки на 90 градусов.

* В режиме игры "Вид сбоку" вид на поле, как ни странно - сбоку, а управление
  героем возможно в формате погружения/всплытия и движения влево/вправо:  

  + `UP` – "всплытие" приводит к перемещению героя на одну клетку вверх
    без смены его изначального направления.
  + `DOWN` – "погружение" приводит к перемещению героя на одну клетку вниз
    без смены его изначального направления.
  + `LEFT` – приводит к развороту и перемещению героя на 1 клетку влево.
  + `RIGHT` – приводит к развороту и перемещению героя на 1 клетку вправо.
  
## Настройки

Параметры будут меняться[(?)](#ask) по ходу игры.

## Кейзы

## <a id="ask"></a> Спроси Сенсея

Параметры могут изменяться по ходу игры. Настройки текущей игры
ты сможешь всегда [подглядеть тут](/codenjoy-contest/rest/settings/player).
Пожалуйста, спроси у Сенсея как интерпретировать эти данные. Ты можешь найти Сенсея
в чате, который подготовили организаторы для обсуждения вопросов.

## Подсказки

Первостепенная задача – написать websocket клиента, который подключится
к серверу. Затем заставить героя слушаться команды. Таким образом,
игрок подготовится к завтрашней игре. Вторая задача – вести
осмысленную игру и победить.

Если ты не знаешь с чего начать, попробуй реализовать следующие алгоритмы:

* Перейти в случайную пустую соседнюю ячейку.
* Продвинуться вперед в свободную клетку в направлении ближайшего приза.
* Попробуй спрятаться от торпед.
* Попробуй избежать вражеских субмарин и других героев.
* Попробуй стрелять по другим героям.

## Клиент и API

Организаторы предоставляют игрокам подготовленные клиенты в исходном 
коде на нескольких языках. Каждый из этих клиентов уже умеет связываться 
с сервером, принимать и разбирать сообщение от сервера (обычно это называется board)
и отправлять серверу команды.

Слишком много форы клиентский код не дает играющим, поскольку в этом коде
еще надо разобраться, но там реализована логика общения с сервером +
некоторое высокоуровневое API для работы с доской (что уже приятно).

Все языки так или иначе имеют похожий набор методов:

* `Solver`
  Пустой класс с одним методом — ты должен(должна) наполнить его умной логикой.
* `Direcion`
  Возможные направления движения для этой игры.
* `Point`
  `x`, `y` координаты.
* `Element`
  Тип элемента на доске.
* `Board` 
  Содержит логику для удобного поиска и манипуляции элементами на поле.
  Ты можешь найти следующие методы в Board классе:
* `int boardSize();`
  Размер доски.
* `boolean isAt(Point point, Element element);`
  Находится ли в позиции point заданный элемент?
* `boolean isAt(Point point, Collection<Element>elements);`
  Находится ли в позиции point что-нибудь из заданного набора?
* `boolean isNear(Point point, Element element);`
  Есть ли вокруг клеточки с координатой point заданный элемент?
* `int countNear(Point point, Element element);`
  Сколько элементов заданного типа есть вокруг клетки с point?
* `Element getAt(Point point);`
  Элемент в текущей клетке.

## Как провести такой же ивент самостоятельно?

Перед тобой opensource проект. Для реализации своей новой игры, модификации этой игры,
любой другой модификации сервера или исправления найденной ошибки
[форкни проект](https://github.com/codenjoyme/codenjoy.git).
Все инструкции ты найдешь в Readme.md файлах - они подскажут, что делать дальше.

Если у тебя есть вопросы - прошу, задавай их мне
в [скайпе alexander.baglay](skype:alexander.baglay)
или по почте [apofig@gmail.com](mailto:apofig@gmail.com).

Удачной игры и пусть победит сильнейший! 